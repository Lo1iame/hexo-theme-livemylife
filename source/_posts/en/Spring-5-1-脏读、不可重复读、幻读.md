---
title: '[Spring] 5.1 脏读、不可重复读、幻读'
catalog: true
date: 2019-07-27 19:01:09
subtitle: 脏读、不可重复读、幻读
header-img: /img/spring/spring_bg.png
tags:
- Spring
---

# 脏读、不可重复读、幻读

理解这三种由于并发访问导致的数据读取问题，再理解事务隔离级别就简单多了。

## 脏读
脏读：`读取未提交数据`

**例：**

A 事务读取 B 事务尚未提交的数据，此时如果 B 事务发生错误并执行回滚操作，那么 A 事务读取到的数据就是脏数据。就好像原本的数据比较干净、纯粹，此时由于 B 事务更改了它，这个数据变得不再纯粹。这个时候 A 事务立即读取了这个脏数据，但事务 B 良心发现，又用回滚把数据恢复成原来干净、纯粹的样子，而事务 A 却什么都不知道，最终结果就是事务 A 读取了此次的脏数据，称为脏读。

总结：***一个事务读到另一个事务没有提交的数据***


## 不可重复读
不可重复读：`前后多次读取，数据内容不一致`

**例子：**

事务 A 在执行读取操作，由整个事务 A 比较大，前后读取同一条数据需要经历很长的时间 。而在事务 A 第一次读取数据，比如此时读取了小明的年龄为20岁，事务 B 执行更改操作，将小明的年龄更改为30岁，此时事务 A 第二次读取到小明的年龄时，发现其年龄是30岁，和之前的数据不一样了，也就是数据不重复了，系统不可以读取到重复的数据，成为不可重复读。

总结：***一个事务读到另一个事务已提交的数据（update）***


## 幻读
幻读：`前后多次读取，数据总量不一致`

**例子：**

事务 A 在执行读取操作，需要两次统计数据的总量，前一次查询数据总量后，此时事务 B 执行了新增数据的操作并提交后，这个时候事务 A 读取的数据总量和之前统计的不一样，就像产生了幻觉一样，平白无故的多了几条数据，成为幻读。

总结：***一个事务读到另一个事务已提交的数据（insert 或 delete）***


## 不可重复读和幻读到底有什么区别呢？
- 不可重复读是读取了其他事务更改的数据，针对 insert 与 update 操作

解决：使用行级锁，锁定该行，事务 A 多次读取操作完成后才释放该锁，这个时候才允许其他事务更改刚才的数据。


- 幻读是读取了其他事务新增的数据，针对 insert 与 delete 操作

解决：使用表级锁，锁定整张表，事务 A 多次读取数据总量之后才释放该锁，这个时候才允许其他事务新增数据。